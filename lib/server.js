// Generated by CoffeeScript 2.3.2
(function() {
  var SRP, Server, transform;

  transform = require('./transform');

  SRP = require('./srp');

  // This is a high-level client interface for the SRP protocol.
  Server = class Server {
    init(options, callback) {
      var bBuf, length;
      this.vBuf = Buffer.from(options.verifier, 'hex');
      this.saltBuf = Buffer.from(options.salt, 'hex');
      this.compatibility = options.compatibility === true;
      length = options.length || 4096;
      this.srp = new SRP(length);
      if (options.b) {
        bBuf = Buffer.from(options.b, 'hex');
        this.bInt = transform.buffer.toBigInteger(bBuf);
        this.BBuf = this.srp.B({
          b: this.bInt,
          v: transform.buffer.toBigInteger(this.vBuf)
        });
        return callback();
      } else {
        return this.srp.b((err, b) => {
          this.bInt = b;
          this.BBuf = this.srp.B({
            b: this.bInt,
            v: transform.buffer.toBigInteger(this.vBuf)
          });
          return callback();
        });
      }
    }

    getPublicKey() {
      return this.BBuf.toString('hex');
    }

    getPrivateKey() {
      var bBuf;
      bBuf = transform.bigInt.toBuffer(this.bInt);
      return bBuf.toString('hex');
    }

    getSalt() {
      return this.saltBuf.toString('hex');
    }

    setClientPublicKey(hexA) {
      var ABigInt;
      this.ABuf = Buffer.from(hexA, 'hex');
      ABigInt = transform.buffer.toBigInteger(this.ABuf);
      if (this.srp.isZeroWhenModN(ABigInt)) {
        throw Error('Invalid A value, abort');
      }
      // We have been given B, which means we can calculate u.
      this.uInt = this.srp.u({
        A: this.ABuf,
        B: this.BBuf
      });
      // We can also calculate our secret.
      this.SBuf = this.srp.serverS({
        A: transform.buffer.toBigInteger(this.ABuf),
        v: transform.buffer.toBigInteger(this.vBuf),
        u: this.uInt,
        b: this.bInt
      });
      // Once we have the secret, we can calculate K.
      return this.KBuf = this.srp.K({
        S: this.SBuf
      });
    }

    getSharedKey() {
      return this.KBuf.toString('hex');
    }

    checkClientProof(M1hex) {
      var clientM1Buf, result;
      clientM1Buf = Buffer.from(M1hex, 'hex');
      if (this.compatibility) {
        this.M1Buf = this.srp.M1({
          A: this.ABuf,
          B: this.BBuf,
          K: this.SBuf
        });
      } else {
        this.M1Buf = this.srp.M1({
          A: this.ABuf,
          B: this.BBuf,
          K: this.KBuf
        });
      }
      result = this.M1Buf.toString('hex') === clientM1Buf.toString('hex');
      return result;
    }

    getProof() {
      var result;
      if (this.compatibility) {
        this.M2Buf = this.srp.M2({
          A: this.ABuf,
          M: this.M1Buf,
          K: this.SBuf
        });
      } else {
        this.M2Buf = this.srp.M2({
          A: this.ABuf,
          M: this.M1Buf,
          K: this.KBuf
        });
      }
      result = this.M2Buf.toString('hex');
      return result;
    }

  };

  module.exports = Server;

}).call(this);
