// Generated by CoffeeScript 2.3.2
(function() {
  var Client, SRP, transform;

  transform = require('./transform');

  SRP = require('./srp');

  // This is a high-level client interface for the SRP protocol.
  Client = class Client {
    // Init generates the "a" value and stores it.
    init(options, callback) {
      var length;
      this.IBuf = Buffer.from(options.username);
      this.PBuf = Buffer.from(options.password);
      length = options.length || 4096;
      this.srp = new SRP(length);
      return this.srp.a((err, a) => {
        this.aInt = a;
        this.ABuf = this.srp.A({
          a: this.aInt
        });
        return callback();
      });
    }

    // Over-ride random "a" selection
    debugInit(options, callback) {
      var length;
      this.IBuf = Buffer.from(options.username);
      this.PBuf = Buffer.from(options.password);
      length = options.length || 4096;
      this.srp = new SRP(length);
      this.aInt = transform.buffer.toBigInteger(options.a);
      this.ABuf = this.srp.A({
        a: this.aInt
      });
      return callback();
    }

    getPublicKey() {
      return this.ABuf.toString('hex');
    }

    // Set the salt value. Salt should be provided in HEX format.
    setSalt(hexSalt) {
      this.saltBuf = Buffer.from(hexSalt, 'hex');
      // Now that we have the salt, we can also calulate x.
      return this.xInt = this.srp.x({
        I: this.IBuf,
        P: this.PBuf,
        salt: this.saltBuf
      });
    }

    // Set the server B value, B should be provided in hex as well.
    // RFC 2945 states that we must abort authentication if B % N is zero.
    setServerPublicKey(hexB) {
      var BBigInt;
      this.BBuf = Buffer.from(hexB, 'hex');
      BBigInt = transform.buffer.toBigInteger(this.BBuf);
      if (this.srp.isZeroWhenModN(BBigInt)) {
        throw Error('Invalid B value, abort');
      }
      // We have been given B, which means we can calculate u.
      this.uInt = this.srp.u({
        A: this.ABuf,
        B: this.BBuf
      });
      // We can also calculate our secret.
      this.SBuf = this.srp.clientS({
        B: transform.buffer.toBigInteger(this.BBuf),
        a: this.aInt,
        u: this.uInt,
        x: this.xInt
      });
      // Once we have the secret, we can calculate K.
      return this.KBuf = this.srp.K({
        S: this.SBuf
      });
    }

    // Get our M1 in Hex value to send to the server for verification.
    getProof() {
      this.M1Buf = this.srp.M1({
        A: this.ABuf,
        B: this.BBuf,
        K: this.KBuf
      });
      return this.M1Buf.toString('hex');
    }

    // Allow us to verify the server's M2 response.
    checkServerProof(hexM2) {
      var ServerM2Buf, result;
      ServerM2Buf = Buffer.from(hexM2, 'hex');
      this.M2Buf = this.srp.M2({
        A: this.ABuf,
        M: this.M1Buf,
        K: this.KBuf
      });
      result = this.M2Buf.toString('hex') === ServerM2Buf.toString('hex');
      return result;
    }

    // Return the shared key K in hex format so that it can be used with other
    // libraries.
    getSharedKey() {
      return this.KBuf.toString('hex');
    }

    createVerifier(callback) {
      return this.srp.generateSalt((err, salt) => {
        var result;
        this.saltBuf = salt;
        result = this.srp.v({
          I: this.IBuf,
          P: this.PBuf,
          salt: this.saltBuf
        });
        result = result.toString('hex');
        return callback(null, {
          verifier: result,
          salt: this.getSalt()
        });
      });
    }

    getSalt() {
      return this.saltBuf.toString('hex');
    }

  };

  module.exports = Client;

}).call(this);
